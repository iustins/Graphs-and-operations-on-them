# Graphs-and-operations-on-them

-Problema 1:
Pentru rezolvarea problemei 1 mi-am creat doua structuri: o structura nod cu campurile index si dist (unde dist reprezinta distanta la care se afla respectivul nod fata de origine), si o structura muchie care are drept campuri 2 campuri de tip nod, unul numit st si celalalt dr. Mi-am creat de asemenea si o functie myfunction care sa ma ajute sa implementez algoritmul de sortare sort din biblioteca algorithm. Aceasta functie myfunction este de tip boolean si intoarce 1 daca nodul i este situat la o distanta mai mica decat nodul j fata de nodul din origine.

Citim din fisierul "p1.in" N-ul si mai apoi citim din acelasi fisier cele N elemente ale vectorului de distante v. Voi crea un nou vector numit vec, care este un vector de structuri de tip nod, campul index al fiecarui fiind completat cu pozitia pe care o ocupa in timp ce campul dist este completat pe baza informatiilor din vectorul v cu distanta de la acel nod pana la sursa.Mai apoi, ne folosim de functia sort pentru a sorta vectorul vec. Dupa sortare, vom avea vectorul vec sortat crescator dupa campul dist al fiecarui element (adica dupa distanta la care se afla fata de nodul origine). Daca elementul vec[2] are campul dist = 0, acest lucru,tinand cont de faptul ca acum vectorul este sortat, inseamna ca si vec[1].dist este egal cu 0 si ajungem la un non-sens (ca am avea cel putin 2 origini). Altfel, initializez variabila min cu vec[1] si voi parcurge vectorul vec, incepand cu al doilea element, in felul urmator: daca diferenta de distante dintre nodul curent si nodul anterior este mai mare ca 1, atunci inseamna ca nu putem construi un graf conform conditiilor cerute (lipseste cel putin un nod din lant). Daca diferenta de distante dintre nodul curent din vec si min.dist este egala cu 1 atunci inseamna ca dubletul format din nodul min si nodul curent din vec reprezinta o noua muchie. In cadrul unui al treilea if voi verifica daca diferenta de distante dintre nodul curent din vec si minimul min este egala cu 2 atunci inseamna ca am gasit un nou minim "local" reprezentat de elementul anterior vec[i-1] din vector care astfel poate deveni capatul din stanga a cel putin unei muchii. Astfel minimul este actualizat cu valoarea acestui nod, care alaturi de elementul curent din vector formeaza o noua muchie.La fiecare muchie nou-descoperita, contorul cnt initializat cu 0, creste cu 1, in final avand valoarea numarului de muchii ale grafului. De mentionat ca la fiecare muchie nou-descoperita, o introduc in vectorul de muchii rez.

La afisare afisez in "p1.out" intai pe o coloana valoarea contorului cnt si mai apoi prin intermediul unui for, pe cate o linie, indexul primului nod al muchiei i si indexul celuilalt nod(capat) al aceleiasi muchii i.


-Problema 2:

In programul meu voi avea nevoie de o structura coordinates care va retine in campul x linia pe care se afla un numar in matricea de noduri vizitate si in campul y coloana pe care se afla un numar in matricea de noduri vizitate. Dupa ce citesc datele de intrare, initializez aria maxima cu minimul posibil adica cu 0.

Pentru a rezolva problema data trebuie sa facem mai multe parcurgeri "bfs modificate", de fiecare data pornind din cate un element al matricei c si luand acest element drept sursa pentru algoritmul "bfs modificat" pe care urmeaza sa il aplicam. De fiecare data cand aplic acest algoritm "bfs modificat", elementul sursa il consider pentru incep atat drept minim cat si drept maxim al elementelor din zona care se construieste. In index.x pun linia nodului sursa iar in index.y pun coloana nodului sursa. Ulterior dau push nodului sursa in coada q si aria zonei o initializez cu 1, deoarece zona contine deja un element. De asemenea, marchez acest nod ca vizitat atribuind elementului visited[i][j] valoarea 1.

Apoi vom avea o bucla while care va rula atata timp cat coada q nu este goala. In cadrul fiecarei repetari a buclei while, la inceput retinem inceputul cozii in variabila fr, iar in variabila k vom stoca "abscisa" lui fr, in timp ce in l vom stoca "ordonata" lui fr. Mai apoi, pentru cele 4 pozitii posibile de casute vecine, vom verifica in primul rand daca acestea exista in matrice (in functie de coordonate). Daca exista acest vecin (fie deasupra, fie in stanga, fie in dreapta, fie dedesubt) voi modifica (adica voi adauga/scadea 1 la una dintre coordonatele primului element din coada) pentru a retine in newindex coordonatele noului vecin.Apoi, pentru a ma ajuta in logica programului voi avea 2 variabile, ok si ok2, care vor avea fie valoarea 1 fie valoarea 0. Variabila ok imi e necesara in procesul de verificare daca acel nod a mai fost vizitat sau nu. Astfel intai il initializez cu valoarea 1 plecand de la prezumtia ca nu a mai fost vizitat si ulterior daca se dovedeste ca la coordonatele corespunzatoarea lui newindex in matricea visited exista deja un element atunci inseamna ca nodul respectiv a mai fost vizitat si atunci ok capata valoarea 0. Daca nodul respectiv nu fost vizitat (ok = 1) ramane sa verificam daca acest vecin poate intra in spatiul solutiilor si daca putem sa tinem cont de el atunci cand facem calculul ariei.

De variabila ok2 ma folosesc tot cu acelasi rol de semnalizator. Valoarea nodului curent, c[newindex.x][newindex.y], are doar 3 pozitii relative fata de axa pe care sunt situate minimul si maximul curent. Daca nodul curent este cuprins intre acest minim si maxim, atunci el devine automat vecin valabil.Altfel, daca nodul curent este mai mic decat minimul curent dar totusi diferenta in modul dintre el si maximul curent este cel mult egala cu k, atunci ok2 devine 1 si minimul este actualizat cu valoarea nodului curent. Altfel, daca nodul curent este mai mare decat maximul curent dar diferenta in modul dintre nodul curent si minim este egala cel mult cu k, atunci ok2 devine 1 si valoarea maximului este actualizata la cea a nodului curent. In final, dupa aceste comparatii de distante, e suficient ca cel putin o data ok2 sa fi luat valoarea 1 pentru a fi siguri ca nodul curent este cu siguranta vecin al nodului anterior si indeplineste si conditia ca diferenta sa fie de cel mult k, deci vom face push nodului newindex in coada, apoi vom considera acest nod de vizitat, punand valoarea 1 in pozitia corespunzatoarea din matricea visited si in final vom mari aria cu 1. Inainte ca iteratia curenta sa se incheie scoatem din coada primul element al cozii q, folosind functia pop. Dupa fiecare aplicare a acestui algoritm "bfs modificat" "curatam" matricea visited, punand valoarea 0 in fiecare element al ei. De asemenea, tot in acest stadiu, mai verificam si daca aria zonei proaspat parcurse este mai mare decat aria maxima, si daca da atunci actualizam aria maxima.




